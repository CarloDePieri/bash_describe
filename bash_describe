#!/bin/bash
#
# TODO

#
# HELPERS
#
setup_colors() {
  # setup colors variable
  if [[ -t 2 ]] && [[ -z "${NO_COLOR-}" ]] && [[ "${TERM-}" != "dumb" ]]; then
    NOFORMAT='\033[0m' RED='\033[0;31m' GREEN='\033[0;32m' ORANGE='\033[0;33m' BLUE='\033[0;34m' PURPLE='\033[0;35m' CYAN='\033[0;36m' YELLOW='\033[1;33m'
  else
    NOFORMAT='' RED='' GREEN='' ORANGE='' BLUE='' PURPLE='' CYAN='' YELLOW=''
  fi
}

msg() {
  # print a message
  echo >&2 -e "${1-}"
}

die() {
  # print a message and quit
  local msg=$1
  local code=${2-1}
  msg "$msg"
  exit "$code"
}

copy_function() {
    declare -F $1 > /dev/null || return 1
    eval "$(echo "${2}()"; declare -f ${1} | tail -n +2)"
}

get_hash() {
  hash=$(echo "$@" | md5sum | cut -f1 -d " ")
}

copy_function_as_its_hash() {
  # TODO
  get_hash "$(declare -f "$1")"
  copy_function "$1" "$hash"
}

is_assert_function_set() {
  #
  # return 0 if the assert function exists

  declare -F "assert" > /dev/null
  return $?
}

get_current_group_id() {
  # TODO
  # WARN: only available when defining tests
  if [[ ${#current_group_path[@]} -gt 0 ]]; then
    last_id=$((${#current_group_path[@]} - 1))
    echo "${current_group_path[$last_id]}"
  else
    echo "-1"
  fi
}

#
# GLOBAL STATE
#

# This will contain the next test name
test_name=""

declare -g -a tests_names
declare -g -a tests_hashes
declare -g -a tests_group

declare -g -a groups_names
declare -g -a current_group_path

#
# TEST DEFINITIONS
#
# This is the accepted format for a test assertion:
#
# it "should work"
#   assert() { true; }
# it
#

it() {
  #
  # set the name for the next test

  # Check if the it/ti functions have been called correctly
  if [[ "$test_name" != "" ]]; then
    die "${RED}ERR: \`it\` called, but a previous \`ti\` seems missing (probably from the test '$test_name')${NOFORMAT}".

  elif is_assert_function_set; then
    msg="${RED}ERR: \`it\` called, but a function called assert was already defined: assert functions${NOFORMAT}"
    msg="$msg should only be defined inside it/ti blocks.${NOFORMAT}"
    die "$msg"

  else
    test_name="it ${1-"should work"}"

  fi
}

ti() {
  #
  # This is the main test runner
  #
  # TODO

  # Check if the it/ti functions have been called correctly
  if [[ -z ${test_name+x} ]] || [[ "$test_name" == "" ]]; then
    die "${RED}ERR: \`ti\` called without a matching \`it\`${NOFORMAT}"

  elif ! is_assert_function_set; then
    die "${RED}ERR: no assert function was found. Define one in the it/ti block of $test_name.${NOFORMAT}"

  else

    # register the test
    copy_function_as_its_hash assert
    tests_hashes+=("$hash")
    tests_names+=("$test_name")
    tests_group+=("$(get_current_group_id)")

    # reset test global state
    test_name=""
    unset assert

  fi
}


#
# GROUPS DEFINITIONS
#

describe() {
  groups_names+=("${1-"A group"}")
  group_id=$((${#groups_names[@]} - 1))
  current_group_path+=("$group_id")
}

described() {
  unset 'current_group_path[${#current_group_path[@]}-1]'
}

#
# FUNCTION RUNNING HELPERS
#
run(){
  # TODO
  local run_file="run_output"
  ("$1" >"$run_file" 2>&1)
  run_exit_code=$?
  run_output=$(cat "$run_file")
  rm "$run_file"
}

exit_code_is() {
  # TODO
  if [[ "$run_exit_code" == "$1" ]]; then
    return 0
  else
    return 1
  fi
}

output_contains() {
  # TODO
  if [[ "$run_output" == *"$1"* ]]; then
    return 0
  else
    return 1
  fi
}

print_output() {
  # TODO
  msg "-DEBUG-\n$run_output\n-------"
}

#
# TEST COLLECTION AND EXECUTION
#
source_all_in_folder() {
  #
  # source all test_*.sh files found in the given path

  local target_folder="$1"

  check_for_tests=$(ls ${target_folder}/test_*.sh >/dev/null 2>&1)
  if [[ "$?" == 0 ]]; then
    for test_file in ${target_folder}/test_*.sh; do
      source "$test_file"
    done
  fi
}

collect_tests() {
  #
  # source all test_*.sh files found in the given path/s (pwd by default)
  # can even source single file if provided (they don't have to respect the test_*.sh name format)

  if [[ "$#" -eq 0 ]]; then
    # Source all test_*.sh files in `pwd`
    source_all_in_folder "$(pwd)"

  else
    # Parse all arguments, if a file source it, if a folder, source all test_*.sh files there
    for arg in "$@"; do
      if [[ -d "$arg" ]]; then
        source_all_in_folder "$arg"
      elif [[ -f "$arg" ]]; then
        source "$arg"
      else
        die "${RED}ERR: \`$arg\` is not a valid folder or file.${NOFORMAT}"
      fi
    done

  fi

  # Unset functions that will not work when running tests
  unset -f get_current_group_id
}

run_tests() {
  #
  # TODO
  #
  for test_id in "${!tests_hashes[@]}"; do

    test_name="${tests_names[$test_id]}"
    test_hash="${tests_hashes[$test_id]}"

    eval "$test_hash"

    if [[ "$?" == "0" ]]; then
      echo "- $test_name"
    else
      echo "x $test_name"
      print_output
    fi

  done
}

#
# MAIN
#
setup_colors
collect_tests "$@"

run_tests
